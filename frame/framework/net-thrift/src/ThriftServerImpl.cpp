// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
/* Copyright(C)
* For free
* All right reserved
* 
*/
/**
* @file ThriftServerImpl.cpp
* @brief thrift服务器实现文件
* @author highway-9, 787280310@qq.com
* @version 1.1.0
* @date 2015-11-25
*/

#include "ThriftServerImpl.h"
#include <assert.h>

/**
* @brief thrift自动生成的代码，用于接收客户端发送的消息
*/
class RPCMessageServiceHandler : virtual public RPCMessageServiceIf 
{
public:
    RPCMessageServiceHandler(ThriftServerImpl* thriftServer)
    {
        // Your initialization goes here

        assert(thriftServer);
        m_thriftServer = thriftServer;
    }

    void sendMessage(std::string& _return, const std::string& message)
    {
        // Your implementation goes here
       
        assert(m_thriftServer->m_messageCallback);

        Message* msg = new Message;
        msg->deserializeSelf(message);
        
        Message* retMsg = new Message;
        retMsg->m_messageType = msg->m_messageType;
        m_thriftServer->m_messageCallback(msg, retMsg);
        if (retMsg)
        {
            _return = retMsg->serializeSelf();
            delete retMsg;
            retMsg = nullptr;
        }

        if (msg)
        {
            delete msg;
            msg = nullptr;
        }
    }

private:
    ThriftServerImpl*       m_thriftServer;
};

ThriftServerImpl::~ThriftServerImpl()
{
    stop();
    deinit();
}

void ThriftServerImpl::init(unsigned int port)
{
    m_port = port;
}

bool ThriftServerImpl::start()
{
    try
    {
        if (m_thread.use_count() == 0)
        {
            m_thread = std::make_shared<std::thread>(serverStart, this);
        }
    }
    catch (TException& e)
    {
        std::cout << "Start server failed, error: " << e.what() << std::endl;
        return false;
    }

    return true;
}

bool ThriftServerImpl::stop()
{
    try
    {
        if (m_threadedServer.use_count() != 0)
        {
            m_threadedServer->stop();

            if (m_thread.use_count() != 0)
            {
                if (m_thread->joinable())
                {
                    m_thread->join();
                }
            }
        }
    }
    catch (TException& e)
    {
        std::cout << "Stop server failed, error: " << e.what() << std::endl;
        return false;
    }

    return true;
}

void ThriftServerImpl::deinit()
{
    // Do nothing.
}

void ThriftServerImpl::serverStart(ThriftServerImpl* server)
{
    shared_ptr<RPCMessageServiceHandler> handler(new RPCMessageServiceHandler(server));
    shared_ptr<TProcessor> processor(new RPCMessageServiceProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(server->m_port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    server->m_threadedServer = std::make_shared<TThreadedServer>(processor, serverTransport, transportFactory, protocolFactory);

    try
    {
        server->m_threadedServer->serve();
    }
    catch (TException& e)
    {
        std::cout << "Error: " << e.what() << std::endl;
    }
}

void ThriftServerImpl::setMessageCallback(MESSAGE_CALLBACK func)
{
    if (func)
    {
        m_messageCallback = func;
    }
}
